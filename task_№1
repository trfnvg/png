struct mydata
{
  uint8_t *vec;
  pthread_t id;
  int start, endd, width, length, bits_per_pixel, j;
  int *gist;

};


void do_work(mydata *work) // функция для построения гистограммы параллельно по строкам
{
    uint8_t r, g, b, brightness;
    for (int k = work->j * work->width; k < work->j * work->width + work->width; k++)
    {
        //printf("%d \n", k);
        r = work->vec[k*(work->bits_per_pixel)];
        g = work->vec[k*(work->bits_per_pixel) + 1];
        b = work->vec[k*(work->bits_per_pixel) + 2];
        brightness = round(0.3*r+0.59*g+0.11*b);
        work->gist[brightness]++;
    }

}

void do_work1(mydata *work1) //функция построения гистограммы за один пробег
{
    uint8_t r, g, b, brightness;
    for (int k = 0; k < work1->width * work1->length; k++)
    {
        //printf("%d \n", k);
        r = work1->vec[k*(work1->bits_per_pixel)];
        g = work1->vec[k*(work1->bits_per_pixel) + 1];
        b = work1->vec[k*(work1->bits_per_pixel) + 2];
        brightness = round(0.3*r+0.59*g+0.11*b);
        work1->gist[brightness]++;
    }
}

void *do_stuff(void *d)
{
  mydata *data=(mydata*)d;
  do_work(data);
  return 0;
}

void *do_stuff1(void *d)
{
  mydata *data1=(mydata*)d;
  do_work1(data1);
  return 0;
}

void gistogramma(int length, int width, int bits_per_pixel, vector<uint8_t>& tmp)
{
  vector<mydata> work(width); //вектор структур
  int gist[255], enter = 0;
  cout << endl;
  for (int k = 0; k < 255; k++)
  {
    gist[k] = 0;
  }
  for (int i = 0; i < width; i++ )
  {
    work[i].j = i;
    work[i].bits_per_pixel = bits_per_pixel;
    work[i].gist = gist;
    work[i].width = width;
    work[i].length = length;
    work[i].vec = &tmp[0];
    //do_work(&work[i]);
  }
  cout << endl;
  
  auto start = chrono::high_resolution_clock::now();
  
  for (int i = 0; i < width; i ++)
  {
      void *ret = (void*)&work[i];
      pthread_create(&work[i].id, 0, do_stuff, ret);
  }

  for (int i = 0; i < width; i ++)
  {
      pthread_join(work[i].id, 0);
  }
  
  auto finish = chrono::high_resolution_clock::now();
  chrono::duration<double> elapsed = finish - start;
  cout << "Elapsed time 1: " << elapsed.count() << " s\n";
  
  for(int k = 0; k < 255; k++)
  {
    if (enter == 50)
    {
      printf("%d ", gist[k]);
      cout << endl;
      enter = 0;
    }
    else
    {
      printf("%d ", gist[k]);
      enter ++;
    }
  }
  enter = 0;
  
  //построили гистограмму через параллельный пробег по строкам
  //теперь построим за один проход

  vector<mydata> work1(width); 

  for (int k = 0; k < 255; k++)
  {
    gist[k] = 0;
  }

  for (int i = 0; i < 1; i++ )
  {
    work1[i].j = i;
    work1[i].bits_per_pixel = bits_per_pixel;
    work1[i].gist = gist;
    work1[i].width = width;
    work1[i].length = length;
    work1[i].vec = &tmp[0];
  }
  cout << endl;
  
  auto start2 = chrono::high_resolution_clock::now();
  
  for (int i = 0; i < 1; i ++)
  {
      void *ret1 = (void*)&work1[i];
      pthread_create(&work1[i].id, 0, do_stuff1, ret1);
  }

  for (int i = 0; i < 1; i ++)
  {
      pthread_join(work1[i].id, 0);
  }
  
  auto finish2 = chrono::high_resolution_clock::now();
  chrono::duration<double> elapsed2 = finish2 - start2;
  cout << "Elapsed time 2: " << elapsed2.count() << " s\n";

  for(int k = 0; k < 255; k++)
  {
    if (enter == 50)
    {
      printf("%d ", gist[k]);
      cout << endl;
      enter = 0;
    }
    else
    {
      printf("%d ", gist[k]);
      enter ++;
    }
  }
}

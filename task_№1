struct mydata
{
  uint8_t *vec;
  pthread_t id;
  int start, endd, width, length, bits_per_pixel, j;
  int *gist;
  int needle_count; // кол-во нитей

};


void do_work(mydata *work)
{
    uint8_t r, g, b, brightness;
    for (int k = work->j * work->width; k < work->j * work->width + work->width; k++)
    {
        r = work->vec[k*(work->bits_per_pixel)];
        g = work->vec[k*(work->bits_per_pixel) + 1];
        b = work->vec[k*(work->bits_per_pixel) + 2];
        brightness = round(0.3*r+0.59*g+0.11*b);
        work->gist[brightness]++;
    }
    if (work->needle_count == 0) // если у нас одна нить продолжаем строить гистограмму (без этого цикла для одной нити была бы обработана только первая строка)
    {
        for (int k = work->width; k < work->width * work->length; k++)
        {
          r = work->vec[k*(work->bits_per_pixel)];
          g = work->vec[k*(work->bits_per_pixel) + 1];
          b = work->vec[k*(work->bits_per_pixel) + 2];
          brightness = round(0.3*r+0.59*g+0.11*b);
          work->gist[brightness]++;
        }
    }
}


void *do_stuff(void *d)
{
  mydata *data=(mydata*)d;
  do_work(data);
  return 0;
}

void *do_stuff1(void *d)
{
  mydata *data1=(mydata*)d;
  do_work(data1);
  return 0;
}

void gistogramma(int length, int width, int bits_per_pixel, vector<uint8_t>& tmp)
{
  int needles = width;
  vector<mydata> work(width);
  int gist[255], enter = 0;
  cout << endl;
  for (int k = 0; k < 255; k++)
  {
    gist[k] = 0;
  }
  for (int i = 0; i < width; i++ )
  {
    work[i].j = i;
    work[i].bits_per_pixel = bits_per_pixel;
    work[i].gist = gist;
    work[i].width = width;
    work[i].length = length;
    work[i].vec = &tmp[0];
    work[i].needle_count = needles;
    //do_work(&work[i]);
  }
  cout << endl;
  auto start = chrono::high_resolution_clock::now();
  for (int i = 0; i < width; i ++)
  {
      void *ret = (void*)&work[i];
      pthread_create(&work[i].id, 0, do_stuff, ret);
  }

  for (int i = 0; i < width; i ++)
  {
      pthread_join(work[i].id, 0);
  }
  auto finish = chrono::high_resolution_clock::now();
  chrono::duration<double> elapsed = finish - start;
  cout << "Elapsed time 1: " << elapsed.count() << " s\n";

  for(int k = 0; k < 255; k++)
  {
    if (enter == 50)
    {
      printf("%d ", gist[k]);
      cout << endl;
      enter = 0;
    }
    else
    {
      printf("%d ", gist[k]);
      enter ++;
    }
  }
  enter = 0;
  needles = 0;

  vector<mydata> work1(width);

  for (int k = 0; k < 255; k++)
  {
    gist[k] = 0;
  }

  for (int i = 0; i < 1; i++ )
  {
    work1[i].j = i;
    work1[i].bits_per_pixel = bits_per_pixel;
    work1[i].gist = gist;
    work1[i].width = width;
    work1[i].length = length;
    work1[i].vec = &tmp[0];
    work[i].needle_count = needles;
  }
  cout << endl;
  auto start2 = chrono::high_resolution_clock::now();
  for (int i = 0; i < 1; i ++)
  {
      void *ret1 = (void*)&work1[i];
      pthread_create(&work1[i].id, 0, do_stuff1, ret1);
  }

  for (int i = 0; i < 1; i ++)
  {
      pthread_join(work1[i].id, 0);
  }
  auto finish2 = chrono::high_resolution_clock::now();
  chrono::duration<double> elapsed2 = finish2 - start2;
  cout << "Elapsed time 2: " << elapsed2.count() << " s\n";

  for(int k = 0; k < 255; k++)
  {
    if (enter == 50)
    {
      printf("%d ", gist[k]);
      cout << endl;
      enter = 0;
    }
    else
    {
      printf("%d ", gist[k]);
      enter ++;
    }
  }
}

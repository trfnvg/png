struct mydata
{
  uint8_t *vec;
  pthread_t id;
  int start, endd, width, length, bits_per_pixel;
  int *gist;

};

void do_work(mydata *work)
{
    uint8_t  r, g, b, brightness;
    for (int k = work->start; k < work -> endd; k += 4)
    {
          r = work->vec[k];
          g = work->vec[k + 1];
          b = work->vec[k + 2];
          brightness = round(0.3*r+0.59*g+0.11*b);
          work->gist[brightness]++;
    }
}

void *do_stuff(void *d)
{
  mydata *data=(mydata*)d;
  do_work(data);
  return 0;
}

void gistogramma(int length, int width, int bits_per_pixel, vector<uint8_t>& tmp)
{
  vector<mydata> work(width);
  int gist[255], enter = 0;
  cout << endl;
  for (int k = 0; k < 255; k++)
  {
    gist[k] = 0;
  }
  int k;
  cout << "Enter the number of parts ";
  cin >> k;
  for (int i = 0; i < k; i++ )
  {
    work[i].bits_per_pixel = bits_per_pixel;
    work[i].gist = gist;
    work[i].width = width;
    work[i].length = length;
    work[i].vec = &tmp[0];
    work[i].start = width * length * bits_per_pixel * i;
    work[i].start /= k;
    work[i].endd = width * length * bits_per_pixel * ( i + 1 );
    work[i].endd /= k;
    //do_work(&work[i]);
  }

  auto start = chrono::high_resolution_clock::now();
  for (int i = 0; i < width; i ++)
  {
      void *ret = (void*)&work[i];
      pthread_create(&work[i].id, 0, do_stuff, ret);
  }

  for (int i = 0; i < width; i ++)
  {
      pthread_join(work[i].id, 0);
  }
  auto finish = chrono::high_resolution_clock::now();
  chrono::duration<double> elapsed = finish - start;
  cout << "Elapsed time 1: " << elapsed.count() << " s\n";

  for(int k = 0; k < 255; k++)
  {
    if (enter == 50)
    {
      printf("%d ", gist[k]);
      cout << endl;
      enter = 0;
    }
    else
    {
      printf("%d ", gist[k]);
      enter ++;
    }
  }
}
